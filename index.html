<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>全球主要指数 · 10年PE（TTM）走势</title>
  <style>
    :root{ --bg:#0b1220; --card:#0f1724; --fg:#e6eef8; --muted:#98a2b3;}
    *{box-sizing:border-box}
    body{margin:0;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,"Helvetica Neue",Arial;background:var(--bg);color:var(--fg)}
    header{padding:20px 24px;border-bottom:1px solid rgba(255,255,255,0.03)}
    h1{margin:0;font-size:20px}
    p.subtitle{margin:6px 0 0;color:var(--muted);font-size:13px}
    main{padding:18px}
    #chart{width:100%;height:68vh;max-height:780px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);border-radius:8px;padding:12px}
    .footer{padding:12px 24px;color:var(--muted);font-size:13px;border-top:1px solid rgba(255,255,255,0.02)}
    .meta{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .badge{background:#0b2540;color:#8ec1ff;padding:6px 10px;border-radius:999px;font-weight:600;font-size:13px}
    @media (max-width:640px){ #chart{height:56vh} header{padding:12px} main{padding:12px} }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
</head>
<body>
  <header>
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div>
        <h1>全球主要指数 · 10年 PE（TTM）走势</h1>
        <p class="subtitle">指数：沪深300 (CSI 300) · 纳斯达克综合 (Nasdaq Composite) · 标普500 (S&P 500) · 恒生指数 (HSI)</p>
      </div>
      <div class="meta">
        <div class="badge">自动更新：每日 北京时间 15:00（数据端）</div>
        <div id="last-update" style="color:var(--muted);font-size:13px">上次更新：--</div>
      </div>
    </div>
  </header>

  <main>
    <div id="chart"></div>
  </main>

  <div class="footer" id="footer">
    数据来源：请在后端 `data/` 文件中放置 CSV 文件（SP500.csv、CSI300.csv、HSI.csv、NASDAQ.csv）。 |
    更新频率：每个交易日北京时间 15:00 自动更新（数据端）。若你需要把来源写成可点链接，请在仓库 README/底注替换。
  </div>

<script>
(function(){
  // 配置：数据文件名（位于 /data/ 目录）
  const sources = [
    {key: "SP500", label: "标普500 (S&P 500)", file: "/data/SP500.csv"},
    {key: "CSI300", label: "沪深300 (CSI 300)", file: "/data/CSI300.csv"},
    {key: "HSI", label: "恒生指数 (HSI)", file: "/data/HSI.csv"},
    {key: "NASDAQ", label: "纳斯达克综合 (Nasdaq Composite)", file: "/data/NASDAQ.csv"}
  ];

  // 重绘间隔（毫秒），页面会每 intervalMilliseconds 拉一次 CSV 并刷新图表
  const intervalMilliseconds = 60 * 1000; // 60s

  // ECharts 实例
  const el = document.getElementById('chart');
  const chart = echarts.init(el, null, {renderer:'canvas', useDirtyRect: true});

  // Utility: fetch CSV -> [{date, pe}]
  async function fetchCSV(url){
    try {
      const res = await fetch(url + "?v=" + Date.now(), {cache: "no-store"});
      if(!res.ok) throw new Error(`HTTP ${res.status}`);
      const txt = await res.text();
      const lines = txt.trim().split(/\r?\n/).filter(Boolean);
      if(lines.length <= 1) return [];
      const head = lines[0].split(',');
      const dateIdx = head.findIndex(h => /date/i.test(h));
      const peIdx = head.findIndex(h => /pe/i.test(h));
      if(dateIdx < 0 || peIdx < 0){
        // fallback: assume first two columns
        return lines.slice(1).map(r => {
          const cs = r.split(',');
          return {date: cs[0], pe: parseFloat(cs[1])};
        }).filter(x => !isNaN(x.pe));
      }
      return lines.slice(1).map(r => {
        const cs = r.split(',');
        return {date: cs[dateIdx], pe: parseFloat(cs[peIdx])};
      }).filter(x => !isNaN(x.pe));
    } catch (e) {
      console.warn("fetchCSV error", url, e);
      return [];
    }
  }

  // Load all sources and build unified date axis
  async function loadAll(){
    const results = {};
    for(const s of sources){
      results[s.key] = await fetchCSV(s.file);
    }
    // build master sorted date list (string) from 10 years window
    // keep as YYYY-MM-DD or ISO string; ECharts category axis uses them as strings
    const dateSet = new Set();
    Object.values(results).forEach(arr => arr.forEach(r => dateSet.add(r.date)));
    const dates = Array.from(dateSet).sort((a,b) => new Date(a) - new Date(b));
    // trim to last 10 years
    const tenYearsAgo = new Date();
    tenYearsAgo.setFullYear(tenYearsAgo.getFullYear() - 10);
    const filteredDates = dates.filter(d => new Date(d) >= tenYearsAgo);
    // Build series data aligned to filteredDates
    const series = sources.map(s => {
      const map = new Map(results[s.key].map(r => [r.date, r.pe]));
      const data = filteredDates.map(d => (map.has(d) ? (isFinite(map.get(d))? map.get(d): null) : null ));
      return {name: s.label, data};
    });
    return {dates: filteredDates, series};
  }

  // Render
  async function render(){
    const payload = await loadAll();
    const option = {
      backgroundColor: getComputedStyle(document.documentElement).getPropertyValue('--bg') || '#0b1220',
      textStyle: { color: getComputedStyle(document.documentElement).getPropertyValue('--fg') || '#e6eef8'},
      tooltip: {
        trigger: 'axis',
        axisPointer: {type: 'cross'},
        formatter: function(params){
          // params is array for each series, show date + values
          if(!params || !params.length) return '';
          let s = `<div style="font-weight:700">${params[0].axisValue}</div>`;
          params.forEach(p => {
            const v = (p.value==null || isNaN(p.value))? '—' : p.value.toFixed(2);
            s += `<div style="margin-top:4px"><span style="display:inline-block;width:10px;height:10px;background:${p.color};margin-right:8px;border-radius:2px"></span>${p.seriesName}: <b>${v}</b></div>`;
          });
          return s;
        }
      },
      legend: { top: 12, textStyle: {color: '#cbd5e1'} },
      grid: { left: 50, right: 30, top: 60, bottom: 60 },
      xAxis: {
        type: 'category',
        data: payload.dates,
        boundaryGap: false,
        axisLabel: { formatter: v => v.slice(0,10) }
      },
      yAxis: {
        type: 'value',
        name: 'PE（TTM）',
        nameLocation: 'middle',
        nameGap: 40,
        axisLine: { show: false },
        splitLine: { show: true }
      },
      series: payload.series.map((s, idx) => ({
        name: s.name,
        type: 'line',
        showSymbol: false,
        sampling: 'lttb',
        smooth: false,
        data: s.data,
        connectNulls: false,
        lineStyle: { width: 2 },
        emphasis: { focus: 'series' }
      }))
    };
    chart.setOption(option, {notMerge: true});
    // update status (last-modified via /status)
    try {
      const st = await fetch('/status?v=' + Date.now()).then(r=>r.json());
      const files = st.files || {};
      const times = Object.keys(files).map(k => files[k].last_modified_utc || '').filter(Boolean);
      if(times.length) {
        document.getElementById('last-update').textContent = '上次数据更新时间（UTC）: ' + times.join(' | ');
      } else {
        document.getElementById('last-update').textContent = '上次更新：暂无数据';
      }
    } catch (e) {
      // ignore
    }
  }

  // initial render
  render();

  // periodic refresh
  setInterval(render, intervalMilliseconds);

  // responsive
  window.addEventListener('resize', () => chart.resize());
})();
</script>
</body>
</html>
